<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web Tester</title>

    <script src='assets/eosjs-api.js'></script>
    <script src='assets/eosjs-jsonrpc.js'></script>
    <script src='assets/eosjs-jssig.js'></script>
    <script src="../../bundles/scatterjs-core.min.js"></script>

    <!--<script>-->
	    <!--window.lynxMobile = {-->
		    <!--requestSetAccount:() => {-->
	            <!--const accounts = [{-->
		            <!--name:'testaccount1',-->
		            <!--authority:'active',-->
		            <!--publicKey:'EOS5Jzkpde9pDNTPjyWqcHwvNkrXQma8VPV9qZ3fNu5dvZkiLEKxG',-->
		            <!--blockchain:'eos',-->
		            <!--isHardware:false,-->
		            <!--chainId:'EOS5Jzkpde9pDNTPjyWqcHwvNkrXQma8VPV9qZ3fNu5dvZkiLEKxG'-->
	            <!--}];-->

	            <!--const identity = {-->
		            <!--name:accounts[0].name,-->
		            <!--accounts,-->
		            <!--publicKey:'EOS8RFgis6KAbChv89L3ibPmSH9raqN3iaFWbyLrDgmAuV3rsZ9SM'-->
	            <!--};-->

	            <!--ScatterJS.scatter.identity = identity;-->
	            <!--console.log(ScatterJS.scatter.identity);-->
	            <!--return identity;-->
            <!--},-->
            <!--requestArbitrarySignature:x => { console.log(x); },-->
		    <!--requestSignature:x => { console.log(x); }-->
	    <!--};-->
    <!--</script>-->

    <script src="../../bundles/scatterjs-plugin-eosjs2.min.js"></script>
    <script src="../../bundles/scatterjs-plugin-lynx.min.js"></script>
</head>
<body>
<div id="status"></div>
<br>
<br>

<button onclick="login()">Get Identity</button>
<button onclick="logout()">Forget Identity</button>
<button onclick="transfer()">Transfer</button>
<button onclick="hookTransfer()">Hook Transfer</button>
<button onclick="transferDualSign()">Multi Hook Transfer</button>
<button onclick="authenticate()">Authenticate</button>

<script>



	ScatterJS.plugins( new ScatterEOS(), new ScatterLynx({Api:eosjs_api.default, JsonRpc:eosjs_jsonrpc.default, textEncoder:() => {}}) );

	const network = ScatterJS.Network.fromJson({
		blockchain:'eos',
		chainId:'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',
		host:'nodes.get-scatter.com',
		port:443,
		protocol:'https'
	});

    // const network = ScatterJS.Network.fromJson({
    //     blockchain:'eos',
    //     chainId:'cf057bbfb72640471fd910bcb67639c22df9f92470936cddc1ade0e2f2e7dc4f',
    //     host:'192.168.1.6',
    //     port:8888,
    //     protocol:'http'
    // });

	// const network = ScatterJS.Network.fromJson({
    //     blockchain:'eos',
    //     chainId:'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473',
    //     host:'dev.cryptolions.io',
    //     port:18888,
    //     protocol:'http'
	// });

	let scatter = null;

	const rpc = new eosjs_jsonrpc.default(network.fullhost());

	const getApi = (signatureProvider) => new eosjs_api.default({ rpc, signatureProvider });

	const getScatterEos = () => scatter.eos(network, eosjs_api.default, {rpc});

	const setStatus = () => {
		const status = document.getElementById('status');
		if(!scatter) return status.innerText = 'No Scatter';
		if(!scatter.identity) return status.innerText = 'No Identity';
		status.innerText = scatter.identity.name;
	};

	setStatus();
	setInterval(() => {
		setStatus();
	}, 50);

	ScatterJS.scatter.connect('eosjs2-test', {network}).then(connected => {
		console.log('connect', connected);
		if(!connected) return false;
		scatter = ScatterJS.scatter;
	});

	window.login = async () => await scatter.login();
	window.logout = () => scatter.logout();

	window.transfer = async () => {
		const api = getScatterEos();
		tryTransfer(api);
	};

	window.transferDualSign = async () => {
		const SECONDARY_ACCOUNT_NAME = '';

		// DON'T EVER DO THIS FROM A FRONT END! YOU WILL LOSE YOUR KEYS!
        // Check out the API signer flow below.
		const localSigner = new eosjs_jssig.default([
			'SOME_PRIVATE_KEY',
        ]);

		const signatureProvider = scatter.eosMultiHook(network, [localSigner]);

		const api = new eosjs_api.default({ rpc, signatureProvider });
		const from = scatter.identity.accounts[0];
		try {
			const from = scatter.account('eos');
			const result = await api.transact({
				actions: [{
					account: 'eosio.token',
					name: 'transfer',
					authorization: [{
						// Account which pays for resources must be first!
						actor: SECONDARY_ACCOUNT_NAME,
						permission: 'active',
					},{
						actor: from.name,
						permission: from.authority,
					}],
					data: {
						from: from.name,
						to: 'safetransfer',
						quantity: '0.0001 EOS',
						memo: from.name,
					},
				}]
			}, {
				blocksBehind: 3,
				expireSeconds: 30,
			});
			console.log('result', result);
		} catch (e) {
			console.error(e);
		}



        // EXAMPLE OF AN API BASED SIGNER FOR THE FRONT END
        // This simply forwards requests from the front end to your filtering API.
        /*
        const apiSigner = {
            getAvailableKeys:async () => fetch('https://your.api/keys'),
            sign:async (signargs) => fetch('https://your.api/sign', {
                   method:"POST",
                body:JSON.stringify(signargs)
            }),
        };
        */

		// SEE HERE FOR SECURITY CONCERNS AND BACKEND API SIGNING EXAMPLE CODE:
        // https://gist.github.com/nsjames/44d9c18879342449a211c49e53c74ccb

// SECURITY CONCERNS!
// Because your backend will be signing transactions, you will need to validate
// the transaction details before actually signing them.
// Using keys designated for specific actions is okay in some situations, but not all
// (like when your dapp wants to pay for eosio.token transfers)

// The best flow for this is the following:
// VISUAL DIAGRAM: https://t.me/ScatterDevelopers/16787
// - Front-end which implements a multi-signer (scatter + api signer)
// - Scatter signs for the user
// - Your signature request goes to your API, which is only a "FILTER"
// - The actual signing machine should be a private network linked machine that only accepts
//   requests from the filtering API. That way the keys don't even live on the same machine
//   that users are exposed to.


// EXAMPLE OF AN API BASED SIGNER FOR THE FRONT END
// This simply forwards requests from the front end to your filtering API.
/*
const apiSigner = {
    getAvailableKeys:async () => fetch('https://your.api/keys'),
    sign:async (signargs) => fetch('https://your.api/sign', {
           method:"POST",
        body:JSON.stringify(signargs)
    }),
};
*/



// EXAMPLE OF AN API FILTER
// You can pop this onto a backend API server and use it to filter incoming requests.
// !!!!!!!!!!!! THIS IS UNTESTED EXAMPLE CODE, PLEASE MAKE SURE IT IS DOING WHAT YOU THINK IT IS !!!!!!!!!!!!

// COPY FROM HERE
/*

// Used for binary conversion https://github.com/EOSIO/eosjs/blob/master/src/eosjs-numeric.ts#L181
import * as numeric from "eosjs/dist/eosjs-numeric";
// Used for proofing the filtering api
import ecc from 'eosjs-ecc';

const PROOFING_KEY = 'EOSIO KEY: LOAD THIS INTO THE MACHINE WHILE IT IS RUNNING USING PROMPTS, OR USE A .env FILE WHICH IS CLEARED AFTER THE PROCESS IS RUNNING';

const filter = async signargs => {


    const YOUR_TARGET_CHAIN = 'aca...';                         // You should know which chain you support
    const YOUR_ACCOUNT = 'hello.world';                         // You should know which account you are receiving things to in the case of transfers
    const TOTAL_ACTIONS = 1;                                    // You should know how many actions you sent from your front end
    const VALID_CONTRACTS = ['eosio.token', 'somethingelse'];   // You should know which contracts your users are able to interact with.

    if(signargs.chainId !== YOUR_TARGET_CHAIN) return console.error('This transaction is not for your chain.');

    const api = Api({...}); // An eosjs2 API object

    const contractAccounts = signargs.abis
        // Gets the contract account names from the ABIs
        .map(x => x.accountName)
        // Makes the array distinct
        .reduce((acc,x) => {
            if(!acc.includes(x)) acc.push(x);
            return acc;
        }, []);

    for(let i = 0; i < contractAccounts.length; i++){
        const account = contractAccounts[i];

        // Gets the raw ABI from the chain (DONT RELY ON THE ABI THAT YOU GOT FROM THE `signargs`!)
        const chainAbi = await fetch(`https://nodes.get-scatter.com/v1/chain/get_raw_abi`, {
            method:"POST",
            body:JSON.stringify({account_name:account})
        }).then(x => x.json()).then(x => x.abi).catch(() => null);

        if(!chainAbi) return console.error('Could not fetch ABI from chain');

        // Binary representation
        const rawAbi = numeric.base64ToBinary(chainAbi);
        // JSON representation
        const abi = api.rawAbiToJson(rawAbi);

        // Caches the ABIs into your instance of eosjs2
        api.cachedAbis.set(account, { rawAbi, abi });
    }

    // Converting the hex signargs back into a buffer
    const buffer = Buffer.from(signargs.serializedTransaction, 'hex');
    // Deserializes the serialized transaction into usable JSON
    const parsed = await api.deserializeTransactionWithActions(buffer);
    const {actions} = parsed;

    if(actions.length !== TOTAL_ACTIONS)
        return console.error('There were either too little or too many actions.');

    for(let i = 0; i < actions.length; i++){
        const action = actions[i];
        const {account, name, data} = action;

        // YOUR CUSTOM LOGIC HERE!

        if(!VALID_CONTRACTS.includes(account)) return console.error(`This contract isn't supported: `, data);

        if(account === 'eosio.token'){
            if(name !== 'transfer') return console.error('Only transfers are allowed on this contract: ', data);
            if(data.to !== YOUR_ACCOUNT || data.from === YOUR_ACCOUNT) return console.error(`This transfer wasn't sending EOS to you, or was sending to you.`, data);
        }
    }

    // Recreating a signable signature from the transaction we've validated.
    // Don't assume anything that came from the signargs is good to sign.
    // (even though in the case of eosjs2 this is made directly from `signargs.serializedTransaction`)
    const toSign = Buffer.concat([
        new Buffer(signargs.chainId, "hex"),            // Chain ID
        buffer,                                         // Transaction
        new Buffer(new Uint8Array(32)),                 // Context free actions
    ]);

    // Though this is good, I'd have an authentication key on this filtering API
    // which only exists on running scope, and it used to also sign this and proove
    // it came from the filtering machine's running process, and not someone who
    // might have gained access to the filtering machine but doesn't have the proofing key.
    const signedProof = ecc.sign(toSign, PROOFING_KEY);

    // Send the transaction to sign + the proof this machine executed filtering to
    // your other privately networked signing machine.
    return signWithOtherMachine(toSign, signedProof);

}

*/
// END COPY HERE


// FOR THE SIGNING MACHINE:
// - validate that the IP the request originated from is a networking machine
//   (in the case that there are other servers in that private network)
// - check that the `signedProof` matches the known public key:
//   `if(ecc.recover(signedProof, toSign) !== KNOWN_PUBLIC_KEY) return false;`
// - sign the `toSign`:
//   `ecc.sign(toSign, SECURE_KEY)`



	};

	window.hookTransfer = async () => {
		const api = getApi(scatter.eosHook(network));
		const from = scatter.identity.accounts[0];
		tryTransfer(api);
	};

	window.authenticate = async () => {
		const getRandom = () => Math.round(Math.random() * 8 + 1).toString();
		let randomString = '';
		for(let i = 0; i < 12; i++) randomString += getRandom();
		console.log('randomString', randomString);
		await scatter.authenticate(randomString).then(res => console.log(res));
	};

	const tryTransfer = async api => {
		try {
			const from = scatter.account('eos');
			const result = await api.transact({
				actions: [{
					account: 'eosio.token',
					name: 'transfer',
					authorization: [{
						actor: from.name,
						permission: from.authority,
					}],
					data: {
						from: from.name,
						to: 'safetransfer',
						quantity: '0.0001 EOS',
						memo: from.name,
					},
				}]
			}, {
				blocksBehind: 3,
				expireSeconds: 30,
			});
			console.log('result', result);
		} catch (e) {
			console.error(e);
		}
	}

</script>
</body>
</html>
